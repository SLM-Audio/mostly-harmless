<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MostlyHarmless: Making an audio fx plugin</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MostlyHarmless<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_FXPluginTutorial.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Making an audio fx plugin </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md15"></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Prerequisites</h1>
<p>Without sounding gatekeepy, mostly harmless wasn't really written with absolute C++ beginners in mind. It's no doubt possible to learn C++ via this framework, but the documentation and tutorials assume relative-fluency with C++ and CMake, (if such a thing actually exists), and the framework code tends to adhere to RAII techniques, liberally throw around terms like <span class="tt">rvalue ref</span>, etc. <br  />
 This isn't to exclude anyone from using the framework, I've just never been great at explaining this sort of thing - so it's moreso a word of warning that if you're just starting out, the JUCE framework will definitely give you a less landmine-filled environment to learn in.</p>
<p>All that being said, if you need help with the framework, you can reach me in The Audio Programmer discord community, I'm @Meijis.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Anatomy</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Engine, Editor and SharedState</h2>
<p>A plugin in mostly harmless is divided into 3 distinct areas:</p>
<ul>
<li><span class="tt">Engine</span>: Contains all audio-thread related functions.</li>
<li><span class="tt">Editor</span>: Contains all gui related functions.</li>
<li><span class="tt">SharedState</span>: Owns any data needed by both the <span class="tt">Engine</span> and <span class="tt">GUI</span> classes.</li>
</ul>
<p><span class="tt">SharedState</span> can loosely be thought of as the Model, and <span class="tt">Engine</span> and <span class="tt">Editor</span> can loosely be thought of as views into <span class="tt">SharedState</span>. <br  />
The reasoning behind this is to force a separation of concerns between different parts of the plugin, by making the <span class="tt">Engine</span> and <span class="tt">GUI</span> completely independent of one another - any comms between the two should take place through <span class="tt">SharedState</span>, via instances of <span class="tt">marvin::containers::fifos::SPSC</span>.</p>
<p>The framework provides mostly-abstract base classes for the user to implement for each of these areas of the plugin, <span class="tt">ISharedState</span>, <span class="tt">IEngine</span>, and <span class="tt">IEditor</span>.</p>
<p><span class="tt">ISharedState</span> requires some extra variables passed from the internal framework, for various useful tasks (running a function on the message thread, and requesting a param flush). These extras are encapsulated in <span class="tt">SharedStateContext</span>, which we'll touch on in the next section.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
PluginEntry</h2>
<p>As the user needs to inform the framework of their custom derived <span class="tt">SharedState</span>, <span class="tt">Engine</span> and <span class="tt">Editor</span> classes, we also provide an interface to specify them - <span class="tt">IPluginEntry</span>, and a macro (<span class="tt"><a class="el" href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b" title="Macro to register your IPluginEntry subclass with the framework.">MH_REGISTER_PLUGIN_ENTRY(EntryType)</a></span>) to register the user's custom <span class="tt">PluginEntry</span> with the framework.</p>
<p>The framework does <em>not</em> enforce that derived classes must take a pointer to an <span class="tt">ISharedState</span> to the <span class="tt">Engine</span> and <span class="tt">Editor</span> constructors, and that is instead left up to the user to implement - the reasoning being to avoid annoying downcasts every time the custom <span class="tt">SharedState</span> class is needed within the other derived types.</p>
<p>However, the function prototypes in <span class="tt">IPluginEntry</span> for <span class="tt">createEngine</span> and <span class="tt">createEditor</span> both take an <span class="tt">ISharedState*</span> parameter, which the user can cast to their custom type, and pass to their derived <span class="tt">Engine</span> and <span class="tt">Editor</span> classes.</p>
<p>As mentioned above, <span class="tt">ISharedState</span> needs an instance of <span class="tt">SharedStateContext</span> passed to its constructor. This is passed by rvalue ref to <span class="tt">IPluginEntry</span>'s <span class="tt">createSharedState</span> function, but it is the user's responsibility to forward this arg to their <span class="tt">SharedState</span> class' base constructor.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Setting it up</h1>
<p>As mentioned above, in order to create a plugin, the user needs to implement <span class="tt">ISharedState</span>, <span class="tt">IEngine</span>, <span class="tt">IEditor</span>, and <span class="tt">IPluginEntry</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
SharedState</h2>
<p>Lets start with the basic boilerplate for our custom <span class="tt">SharedState</span> class.</p>
<div class="fragment"><div class="line"><span class="comment">// SharedState.h</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__ISharedState_8h.html">mostly_harmless/core/mostlyharmless_ISharedState.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>SharedState final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a> { <span class="comment">// [1] </span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> SharedState(mostly_harmless::core::SharedStateContext&amp;&amp; context); <span class="comment">// [2]</span></div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>: </div>
<div class="line">        <span class="keywordtype">void</span> loadState(std::string_view toLoad) <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">        <span class="keywordtype">void</span> saveState(std::ostringstream&amp; dest) <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1core_1_1ISharedState_html"><div class="ttname"><a href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a></div><div class="ttdoc">Base class for the plugin&#39;s shared state.</div><div class="ttdef"><b>Definition</b> mostlyharmless_ISharedState.h:26</div></div>
<div class="ttc" id="amostlyharmless__ISharedState_8h_html"><div class="ttname"><a href="mostlyharmless__ISharedState_8h.html">mostlyharmless_ISharedState.h</a></div></div>
</div><!-- fragment --><p>[1] Here we create a class called <span class="tt">SharedState</span>, deriving from the framework's <span class="tt">ISharedState</span> interface.</p>
<p>[2] As explained earlier, we take an rvalue ref to a <span class="tt">SharedStateContext</span>, to be passed to the base class' constructor.</p>
<p>[3] We also override some pure virtual functions from the base, <span class="tt">loadState</span> and <span class="tt">saveState</span>. These will be called when a host restore's the plugin state, or needs to store the plugin's state respectively.</p>
<p>Next we'll define our functions in a source file.</p>
<div class="fragment"><div class="line"><span class="comment">// SharedState.cpp</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin {</div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { <span class="comment">// [1]</span></div>
<div class="line">        std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">        <span class="comment">// Leave this empty for now</span></div>
<div class="line">        <span class="keywordflow">return</span> params;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SharedState::SharedState(mostly_harmless::core::SharedStateContext&amp;&amp; context) : <a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::ISharedState(std::move(context), createParams()) { <span class="comment">// [2]</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> SharedState::loadState(std::string_view toLoad) { <span class="comment">// [3]</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> SharedState::saveState(std::ostringstream&amp; dest) {</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemostly__harmless_html"><div class="ttname"><a href="namespacemostly__harmless.html">mostly_harmless</a></div><div class="ttdoc">The top-level namespace, contains all things plugin-related.</div><div class="ttdef"><b>Definition</b> mostlyharmless_BusConfig.h:3</div></div>
</div><!-- fragment --><p>[1] <span class="tt">ISharedState</span> also takes a <span class="tt">std::vector&lt;Parameter&lt;float&gt;&gt;</span> as its second constructor arg - this is to register any parameters that may exist with the host internally. For this purpose we create a TU scoped free function to create the params, and for the time being, return an empty vector.</p>
<p>[2] Here we pass our <span class="tt">context</span> arg, and a newly created vector of params (as explained above) to our base class' constructor.</p>
<p>[3] Finally, we implement our <span class="tt">loadState</span> and <span class="tt">saveState</span> functions we declared in our header, and leave them empty for now.</p>
<p>We'll return to our <span class="tt">SharedState</span> class in a little while once the rest of the boilerplate has been set up. For now, let's move on to the <span class="tt">Engine</span> class.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Engine</h2>
<div class="fragment"><div class="line"><span class="comment">// Engine.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__IEngine_8h.html">mostly_harmless/core/mostlyharmless_IEngine.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>IEngine final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1core_1_1IEngine.html">mostly_harmless::core::IEngine</a> { <span class="comment">// [1]</span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> Engine(SharedState* sharedState); <span class="comment">// [2]</span></div>
<div class="line">        <span class="keywordtype">void</span> initialise(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a> context) <span class="keyword">noexcept</span> <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">        <span class="keywordtype">void</span> process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> <span class="keyword">override</span>; <span class="comment">// [4]</span></div>
<div class="line">        <span class="keywordtype">void</span> reset() noexcept override; <span class="comment">// [5]</span></div>
<div class="line">    private: </div>
<div class="line">        SharedState* m_sharedState{ <span class="keyword">nullptr</span> }; <span class="comment">// [2]</span></div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1core_1_1IEngine_html"><div class="ttname"><a href="classmostly__harmless_1_1core_1_1IEngine.html">mostly_harmless::core::IEngine</a></div><div class="ttdoc">Interface for the plugin&#39;s audio processing functionality.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:56</div></div>
<div class="ttc" id="amostlyharmless__IEngine_8h_html"><div class="ttname"><a href="mostlyharmless__IEngine_8h.html">mostlyharmless_IEngine.h</a></div></div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1InitContext_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a></div><div class="ttdoc">Container for context passed to IEngine::initialise.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:17</div></div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1ProcessContext_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a></div><div class="ttdoc">Container for context passed to IEngine::process.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:35</div></div>
</div><!-- fragment --><p>[1] We create an <span class="tt">Engine</span> class, deriving from <span class="tt">IEngine</span>.</p>
<p>[2] We take a single argument to our constructor, a pointer to our previously set-up <span class="tt">SharedState</span> class. We also declare a member variable to store the passed pointer in.</p>
<p>[3] We override <span class="tt">initialise</span>, a pure virtual from <span class="tt">IEngine</span>, which is called to set up audio processing, before the first call to <span class="tt">process</span>. This can be called by any thread by the host, but is guaranteed to not happen concurrently with <span class="tt">process</span> or <span class="tt">reset</span>.</p>
<p>[4] We override <span class="tt">process</span>, a pure virtual from <span class="tt">IEngine</span>, which is called on the audio thread by the host to perform some audio processing.</p>
<p>[5] We override <span class="tt">reset</span>, a pure virtual from <span class="tt">IEngine</span>, which is called to clear any existing internal state by the host, to prepare to be able to play again. This can be called by any thread by the host, but is guaranteed to not happen concurrently with <span class="tt">process</span> or <span class="tt">initialise</span>.</p>
<p>Next we'll implement all of the above in a source file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Engine.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    Engine::Engine(SharedState* sharedState) : m_sharedState(sharedState) { <span class="comment">// [1]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::initialise(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a> context) <span class="keyword">noexcept</span> { <span class="comment">// [2]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> { <span class="comment">// [3]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::reset() noexcept { <span class="comment">// [4]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>[1] Here we store the passed <span class="tt">SharedState</span> instance in our <span class="tt">m_sharedState</span> member, for access later on.</p>
<p>[2] We implement <span class="tt">initialise</span>, which takes an <span class="tt">InitContext</span>, which is a convenience wrapper for making the args extensible, and contains the host's sample rate (<span class="tt">sampleRate</span>), the smallest block size the host can pass (<span class="tt">minBlockSize</span>), and the largest block size the host can pass (<span class="tt">maxBlockSize</span>).</p>
<p>[3] We implement <span class="tt">process</span>, which takes a <span class="tt">ProcessContext</span> - again, a convenience wrapper for making the args extensible, which contains a non-owning-view into the buffer passed by the host (<span class="tt">buffer</span>), and an optional representing the transport state, if it is available (<span class="tt">transport</span>).</p>
<p>[4] We implement <span class="tt">reset</span>, as detailed above.</p>
<p>Next, let's implement our <span class="tt">Editor</span> class.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Editor</h2>
<p>The editor class is a bit more complex than all of the above. Mostly harmless doesn't come with a gui framework bolted on, ala JUCE, and instead expects the user to implement whatever gui framework they like, via the hooks in the <span class="tt">IEditor</span> class.</p>
<p>That being said, the framework provides abstractions over <span class="tt">IEditor</span> for a webview gui, with varying degrees of opinionated-ness. More frameworks are planned here, such as Slint, but for now, Webviews are the only fully featured option out of the box.</p>
<p>A full javascript / html / css / trendy web framework tutorial here is obviously out of scope, so we'll instead assume that some gui project exists within our current project, and we'll focus on the C++ side setup to call into this imaginary gui project. Down the line, a tutorial is planned for the full setup, but for now, the <span class="tt">Gain</span> example will have to suffice, which uses React and Vite.</p>
<p>Disclaimers aside, let's talk specifics on the levels of abstraction mostly harmless provides:</p>
<ul>
<li><span class="tt">IEditor</span> is the aforementioned interface, with no additional functionality.</li>
<li><span class="tt">WebviewBase</span> handles cross platform window management, and creates a webview for the user to use as they see fit. It does <em>not</em> handle bidirectional parameter communications for the user, and exists to serve as an unopinionated abstraction layer over <span class="tt">IEditor</span>.</li>
<li><span class="tt">WebviewEditor</span> derives from <span class="tt">WebviewBase</span>, and takes things a step further. It establishes bindings to javascript events for bidirection parameter comms for the user, and handles the majority of the plumbing between C++ and Javascript.</li>
</ul>
<p>In this tutorial, we'll use <span class="tt">WebviewEditor</span> for simplicity.</p>
<div class="fragment"><div class="line"><span class="comment">// Editor.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__WebviewEditor_8h.html">mostly_harmless/gui/mostlyharmless_WebviewEditor.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>Editor final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1gui_1_1WebviewEditor.html">mostly_harmless::gui::WebviewEditor</a> {  <span class="comment">// [1]</span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> Editor(SharedState* sharedState); <span class="comment">// [2]</span></div>
<div class="line">        <span class="keywordtype">void</span> initialise() <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">    <span class="keyword">private</span>: </div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> m_windowWidth{ 500 }; <span class="comment">// [4]</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> m_windowHeight{ 500 };    </div>
<div class="line">        <span class="keyword">const</span> mostly_harmless::gui::Colour m_backgroundColour{ 0xFF000000 };</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1gui_1_1WebviewEditor_html"><div class="ttname"><a href="classmostly__harmless_1_1gui_1_1WebviewEditor.html">mostly_harmless::gui::WebviewEditor</a></div><div class="ttdoc">An opinionated subclass of WebviewBase, providing default impls for bidirectional comms.</div><div class="ttdef"><b>Definition</b> mostlyharmless_WebviewEditor.h:92</div></div>
<div class="ttc" id="amostlyharmless__WebviewEditor_8h_html"><div class="ttname"><a href="mostlyharmless__WebviewEditor_8h.html">mostlyharmless_WebviewEditor.h</a></div></div>
</div><!-- fragment --><p>[1] We declare an <span class="tt">Editor</span> class, deriving from <span class="tt">WebviewEditor</span>, as discussed above.</p>
<p>[2] Our constructor again takes a pointer to our <span class="tt">SharedState</span> class. Because we're deriving from <span class="tt">WebviewEditor</span>, which actually <em>does</em> require an <span class="tt">ISharedState*</span> passed to its constructor, we in this case don't keep this pointer as a member.</p>
<p>[3] We implement the <span class="tt">initialise</span> function, which is <em>not</em> pure virtual, but is where we need to inject any more functionality for after the webview has been created.</p>
<p>[4] We define some compile time constants for our plugin window's width, height and background colour as members.</p>
<p>Next lets implement all of this in a source file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Editor.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    Editor::Editor(SharedState* sharedState) : </div>
<div class="line">     <a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::gui::WebviewEditor(sharedState, m_width, m_height, m_backgroundColour) { <span class="comment">// [1]</span></div>
<div class="line">        setOptions({.enableDebug = <span class="keyword">true</span> }); <span class="comment">// [2]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Editor::initialise() { </div>
<div class="line">        <a class="code hl_function" href="classmostly__harmless_1_1gui_1_1WebviewEditor.html#a1f971ab269931475d34d5dca242f563d">mostly_harmless::gui::WebviewEditor::initialise</a>(); <span class="comment">// [3]</span></div>
<div class="line">        m_internalWebview-&gt;navigate(<span class="stringliteral">&quot;http://localhost:5173&quot;</span>); <span class="comment">// [4]</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1gui_1_1WebviewEditor_html_a1f971ab269931475d34d5dca242f563d"><div class="ttname"><a href="classmostly__harmless_1_1gui_1_1WebviewEditor.html#a1f971ab269931475d34d5dca242f563d">mostly_harmless::gui::WebviewEditor::initialise</a></div><div class="ttdeci">void initialise() override</div></div>
</div><!-- fragment --><p>[1] Here we call our <span class="tt">WebviewEditor</span> class' constructor, which takes our pointer to an <span class="tt">ISharedState</span>, our desired window width and height, and our desired window's background colour.</p>
<p>[2] For now, we just enable inspect-element functionality on the webview - more options are available here, which we'll discuss later.</p>
<p>[3] <span class="tt">WebviewEditor</span>'s <span class="tt">initialise</span> function is <em>not</em> pure virtual, so we still need to call it before doing our own custom behaviour in <span class="tt">initialise</span>.</p>
<p>[4] For now, we load our gui from localhost - in a later tutorial, we'll talk through instead serving the webview from ram.</p>
<p>We're nearly done with our boilerplate, the last thing we need to do is register our derived classes with the framework.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
PluginEntry</h2>
<p>As discussed earlier, <span class="tt">IPluginEntry</span> is our interface for doing so.</p>
<div class="fragment"><div class="line"><span class="comment">// PluginEntry.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Engine.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Editor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mostly_harmless/core/mostlyharmess_IPluginEntry.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">struct </span>PluginEntry final : <span class="keyword">public</span> <a class="code hl_struct" href="structmostly__harmless_1_1core_1_1IPluginEntry.html">mostly_harmless::core::IPluginEntry</a> { </div>
<div class="line">    <span class="keyword">public</span>:    </div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;mostly_harmless::core::ISharedState&gt; createState(mostly_harmless::core::SharedStateContext&amp;&amp; context) <span class="keyword">override</span>; </div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;mostly_harmless::Core::IEngine&gt; createEngine(<a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a>* sharedState) <span class="keyword">override</span>;</div>
<div class="line">        [[nodiscard]] <span class="keywordtype">bool</span> hasGui() const noexcept override;</div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;<a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::IEditor&gt; createEditor(<a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::ISharedState* sharedState) override; </div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1IPluginEntry_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1IPluginEntry.html">mostly_harmless::core::IPluginEntry</a></div><div class="ttdoc">Interface for registering the user&#39;s subclasses with the framework.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IPluginEntry.h:20</div></div>
</div><!-- fragment --><p>Our header is relatively self explanatory, so let's implement those functions in our source file.</p>
<div class="fragment"><div class="line"><span class="comment">// PluginEntry.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;PluginEntry.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    SharedState* asUserState(<a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a>* sharedState) { <span class="comment">// [1]</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>SharedState*<span class="keyword">&gt;</span>(sharedState);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::core::ISharedState&gt; PluginEntry::createState(mostly_harmless::core::SharedStateContext&amp;&amp; context) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;SharedState&gt;(std::move(context)); <span class="comment">// [2]</span></div>
<div class="line">    } </div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::Core::IEngine&gt; PluginEntry::createEngine(mostly_harmless::core::ISharedState* sharedState) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;Engine&gt;(asUserState(sharedState)); <span class="comment">// [3]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> PluginEntry::hasGui() const noexcept { <span class="comment">// [4]</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::core::IEditor&gt; PluginEntry::createEditor(mostly_harmless::core::ISharedState* sharedState) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;Editor&gt;(asUserState(sharedState)); <span class="comment">// [5]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"><a class="code hl_define" href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b">MH_REGISTER_PLUGIN_ENTRY</a>(myplugin::PluginEntry); <span class="comment">// [6]</span></div>
<div class="ttc" id="amostlyharmless__IPluginEntry_8h_html_ab7eec3b8c12426bc21578d0f27768f0b"><div class="ttname"><a href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b">MH_REGISTER_PLUGIN_ENTRY</a></div><div class="ttdeci">#define MH_REGISTER_PLUGIN_ENTRY(PluginEntryType)</div><div class="ttdoc">Macro to register your IPluginEntry subclass with the framework.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IPluginEntry.h:61</div></div>
</div><!-- fragment --><p>[1] We declare a TU scoped helper function to avoid verbose static casts, for downcasting our <span class="tt">ISharedEditor</span> points to our user <span class="tt">SharedState</span> class.</p>
<p>[2] We create our user <span class="tt">SharedState</span> class, forwarding it the <span class="tt">context</span> arg by move.</p>
<p>[3] We create our <span class="tt">Engine</span> class, passing it a downcast-to-user-state of <span class="tt">sharedState</span>.</p>
<p>[4] We return true from <span class="tt">hasGui()</span>. In the case of a headless plugin, we can return false here, and return a nullptr from <span class="tt">createEditor</span>.</p>
<p>[5] We create our <span class="tt">Editor</span> class, passing it a downcast-to-user-state of <span class="tt">sharedState</span>.</p>
<p>[6] Finally, we call a macro to register this <span class="tt">PluginEntry</span> class with the framework. Internally this defines a free function, <span class="tt">createPluginEntry</span>, which returns our user <span class="tt">PluginEntry</span> type. The internal framework class then uses its hooks to create <span class="tt">SharedState</span>, <span class="tt">Engine</span> and <span class="tt">Editor</span> classes, and forwards relevant function calls to the appropriate places within there classes.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Getting it building</h1>
<p>Mostly harmless uses cmake, and provides some CMake helpers to make setting up your plugin a little more painless.</p>
<p>Familiarity with CMake is assumed here, and some typical options have been ommitted for the sake of brevity (macOS arch to build, windows runtime linking type, codesigning, etc).</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.24)</div>
<div class="line">set(CMAKE_CXX_STANDARD 20)</div>
<div class="line">project(MyPlugin VERSION 0.0.1)</div>
<div class="line">include(FetchContent)</div>
<div class="line">FetchContent_Declare(mostly_harmless</div>
<div class="line">        GIT_REPOSITORY https://github.com/SLM-Audio/mostly-harmless.git</div>
<div class="line">        GIT_TAG main</div>
<div class="line">        GIT_SHALLOW ON</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(mostly_harmless) # [1]</div>
<div class="line"> </div>
<div class="line">mostly_harmless_add_plugin(MyPlugin # [2]</div>
<div class="line">        ID &quot;yourcompany.yourplugin&quot;</div>
<div class="line">        VENDOR &quot;Your Company&quot;</div>
<div class="line">        FORMATS CLAP AU VST3 Standalone # [3]</div>
<div class="line">        AU_BUNDLE_ID &quot;com.yourcompany.yourplugin&quot;</div>
<div class="line">        AU_BUNDLE_VERSION &quot;1&quot;</div>
<div class="line">        MANUFACTURER_CODE &quot;Yrco&quot;</div>
<div class="line">        SUBTYPE_CODE &quot;Ypi1&quot;</div>
<div class="line">        AU_TYPE &quot;aufx&quot;</div>
<div class="line">        FEATURES &quot;audio-effect&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_sources(MyPlugin PRIVATE # [4]</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/PluginEntry.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/SharedState.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/Engine.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/Editor.cpp</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_include_directories(MyPlugin PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/source) # [5]</div>
</div><!-- fragment --><p>[1] We pull in mostly harmless via fetch content - in real life, you probably want to pin this to a specific SHA or tag.</p>
<p>[2] Mostly harmless provides <span class="tt">mostly_harmless_add_plugin</span>, which will set up the specified plugin targets for you, and automatically handle the internal linking, etc.</p>
<p>[3] This is where we specify what formats we want to build. Note that AU requires some extra arguments that the other targets don't - see <a class="el" href="README_8md.html">README.md</a> for more info on this.</p>
<p>[4] We specify what source files the plugin should compile.</p>
<p>[5] We set the <span class="tt">source</span> directory as an include directory for convenience.</p>
<p>At this point, you should be at a stage where your plugin is compiling!</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
A Gain Plugin</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Modifying the input signal's level</h2>
<p>Let's start simple - multiply the audio input by 0.5. Jumping back to our <span class="tt">Engine</span> class, our <span class="tt">process</span> function is the place to do so.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> { </div>
<div class="line">  <span class="keyword">auto</span> buffer = context.buffer;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Firstly, we retrieve the buffer (a <span class="tt">marvin::containers::BufferView&lt;float&gt;</span>) from the <span class="tt">context</span>. You can take a look at the docs for <span class="tt">BufferView</span>, but it can pretty much be thought of a <span class="tt">std::span</span> but for an audio buffer - that is, a non owning view into the passed in audio buffer. Internally in the framework, for sample accurate automation, this buffer view will be from index_of_last_event to index_of_current_event - essentially it's interrupted whenever there's a new param/midi event. See <span class="tt"><a class="el" href="namespacemostly__harmless.html#a8d2d74acdc833b5d2eef76b423e9cf89" title="Splits an input buffer into chunks and dispatches them, allowing for block based processing.">mostly_harmless::runBlockDispatch</a></span> for a more in-depth explanation of this.</p>
<p><span class="tt">BufferView</span> provides functions to grab read / write pointers (RAW pointers) to the underlying data. It's worth noting that these actually point to the same memory, just with different access modifiers, which is a holdover from my JUCE muscle memory.</p>
<p>To start with then, lets grab our read and write pointers..</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers(); <span class="comment">// const T* const *</span></div>
<div class="line"><span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers(); <span class="comment">// T* const *</span></div>
</div><!-- fragment --><p>Now we're set up to apply our gain:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers(); <span class="comment">// const T* const *</span></div>
<div class="line"><span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers(); <span class="comment">// T* const *</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> sample = 0; sample &lt; buffer.getNumSamples(); ++sample) { <span class="comment">// iterate over the samples</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> channel = 0_sz; channel &lt; buffer.getNumChannels(); ++channel) { <span class="comment">// iterate over the channels</span></div>
<div class="line">        write[channel][sample] = read[channel][sample] * 0.5f; <span class="comment">// multiply our input signal by 0.5, and write to the output signal.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running this, you should hear it attenuating the input signal. Great! Now lets make the gain modifyable.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Parameters</h2>
<p>Earlier I mentioned that <span class="tt">ISharedState</span> takes a vector of parameters to its constructor, which registers them internally, and we defined a TU-scoped free function to create our params. Let's revisit that:</p>
<div class="fragment"><div class="line">std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { </div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now - <span class="tt"><a class="el" href="structmostly__harmless_1_1Parameter.html" title="Container class for a single parameter.">mostly_harmless::Parameter</a>&lt;float&gt;</span> - whats the deal with that? At this point it's helpful to get slightly sidetracked, and take a look at the documentation. It's worth noting that there are two overloads of Parameter's constructor - one that takes a ParameterID, and another that takes a raw std::uint32_t. We'll focus on the former here, but you can learn the difference between the two by checking the documentation. The main things we need to worry about here are <span class="tt">pid</span>, <span class="tt">name</span>, <span class="tt">category</span>, <span class="tt">range</span>, <span class="tt">defaultValue</span> and <span class="tt">flags</span>.</p>
<ul>
<li><span class="tt">parameterId</span> is the internally used param id.</li>
<li><span class="tt">name</span> is the parameter's name, which will be displayed in the host.</li>
<li><span class="tt">category</span> is a clap-specific thing, in which you can separate certain parameters by category - this specifies the category.</li>
<li><span class="tt">range</span> is the range of the parameter.</li>
<li><span class="tt">defaultValue</span> is, intuitively, the default value of the parameter.</li>
<li><span class="tt">flags</span> is a set of clap defined flags, to control the parameter's properties.</li>
</ul>
<p><span class="tt">parameterId</span> needs a little elaboration here. In CLAP, the id for a given parameter must be fixed to avoid breaking automation, old presets, old states, and generally maintain backwards compatability. So rather than getting you (the user) to pick an arbitrary unique uint32_t for each parameter, we provide ParameterID. This class takes a non-owning view to a string, and generates that string's hash at construction - the hash is then used as the internal param id. We could have generated this from <span class="tt">name</span>, but separating the two allows you to rename the host/user facing param name at any point, without breaking existing projects, etc. This of course means that the string passed to ParameterID must not change once your plugin is in the wild - this is reiterated a few times in the documentation, but just to really hammer it home...</p>
<p>With that out of the way, armed with our newfound knowledge, lets populate our <span class="tt">createParams</span> function.</p>
<div class="fragment"><div class="line">std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { </div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">    params.emplace_back(<a class="code hl_struct" href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter&lt;float&gt;</a>{ </div>
<div class="line">        <a class="code hl_struct" href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a>{<span class="stringliteral">&quot;gain&quot;</span>}, <span class="comment">// pid</span></div>
<div class="line">        <span class="stringliteral">&quot;Gain&quot;</span>, <span class="comment">// name</span></div>
<div class="line">        <span class="stringliteral">&quot;gain/&quot;</span>, <span class="comment">// category</span></div>
<div class="line">        {.min = 0.0f, .max = 1.0f}, <span class="comment">// range,</span></div>
<div class="line">        1.0f, <span class="comment">// defaultValue</span></div>
<div class="line">        CLAP_PARAM_IS_AUTOMATABLE <span class="comment">// flags</span></div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> params;</div>
<div class="line">}</div>
<div class="ttc" id="astructmostly__harmless_1_1ParameterID_html"><div class="ttname"><a href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a></div><div class="ttdoc">Convenience class for generating a parameter id.</div><div class="ttdef"><b>Definition</b> mostlyharmless_Parameters.h:15</div></div>
<div class="ttc" id="astructmostly__harmless_1_1Parameter_html"><div class="ttname"><a href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter</a></div><div class="ttdoc">Container class for a single parameter.</div><div class="ttdef"><b>Definition</b> mostlyharmless_Parameters.h:41</div></div>
</div><!-- fragment --><p>With this in place, we've created a gain parameter. <span class="tt">ISharedState</span> provides a <span class="tt">getParameterById</span> function which we can use to retrieve a parameter by either a ParameterID, or a <span class="tt">std::uint32_t</span> (the latter being useful if you want to precalculate your hashes, and keep them around in shared state, etc.</p>
<p>However, both of these overloads perform a lookup in a <span class="tt">std::unordered_map</span>. We can live with this, but can also do better. Still within our <span class="tt">ISharedState</span> header/source, lets declare a new type, <span class="tt">ParameterView</span>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ParameterView final { </div>
<div class="line">    <a class="code hl_struct" href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter&lt;float&gt;</a>* gainParam{ <span class="keyword">nullptr</span> };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharedState ....</div>
</div><!-- fragment --><p>And now let's create an instance of <span class="tt">ParameterView</span> as a member of <span class="tt">SharedContext</span>.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>: </div>
<div class="line">    <span class="keywordtype">void</span> loadState(...</div>
<div class="line">    <span class="keywordtype">void</span> saveState(...</div>
<div class="line">    </div>
<div class="line">    ParameterView m_paramView;</div>
</div><!-- fragment --><p>In <span class="tt">SharedState</span>'s constructor, we need to initialise <span class="tt">m_paramView</span>'s <span class="tt">gainParam</span> pointer to a valid parameter:</p>
<div class="fragment"><div class="line">SharedState::SharedState(....) : .... { </div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">auto</span> param = getParameterById(<a class="code hl_struct" href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a>{<span class="stringliteral">&quot;gain&quot;</span>}) { </div>
<div class="line">        m_paramView.gainParam = param; </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> { </div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We've now set up a trivially copyable struct containing raw pointers to our params, and the only lookups happen at construction. To use this in our <span class="tt">Engine</span> and <span class="tt">Editor</span> classes, we need to create a getter:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SharedState final : .... { </div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line">    ...</div>
<div class="line">    [[nodiscard]] ParameterView getParamView() const noexcept;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">ParameterView SharedState::getParamView() const noexcept { </div>
<div class="line">    <span class="keywordflow">return</span> m_paramView;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can finally grab the parameter in our Engine now:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keyword">auto</span> buffer = context.buffer;</div>
<div class="line">    <span class="keyword">auto</span> paramView = m_sharedState-&gt;getParamView();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> gain = paramView.gainParam-&gt;value;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers();                   </div>
<div class="line">    <span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers();                      </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> sample = 0; sample &lt; buffer.getNumSamples(); ++sample) {       </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> channel = 0_sz; channel &lt; buffer.getNumChannels(); ++channel) {</div>
<div class="line">            write[channel][sample] = read[channel][sample] * gain;             </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>// TODO: MORE </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
