<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MostlyHarmless: Making an audio fx plugin</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MostlyHarmless<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_FXPluginTutorial.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Making an audio fx plugin</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md15"></a></p>
<h1><a class="anchor" id="autotoc_md16"></a>
Prerequisites</h1>
<p>Without sounding gatekeepy, mostly harmless wasn't really written with absolute C++ beginners in mind. It's no doubt possible to learn C++ via this framework, but the documentation and tutorials assume relative-fluency with C++ and CMake, (if such a thing actually exists), and the framework code tends to adhere to RAII techniques, liberally throw around terms like <code>rvalue ref</code>, etc. <br  />
 This isn't to exclude anyone from using the framework, I've just never been great at explaining this sort of thing - so it's moreso a word of warning that if you're just starting out, the JUCE framework will definitely give you a less landmine-filled environment to learn in.</p>
<p>All that being said, if you need help with the framework, you can reach me in The Audio Programmer discord community, I'm @Meijis.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Anatomy</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
Engine, Editor and SharedState</h2>
<p>A plugin in mostly harmless is divided into 3 distinct areas:</p>
<ul>
<li><code>Engine</code>: Contains all audio-thread related functions.</li>
<li><code>Editor</code>: Contains all gui related functions.</li>
<li><code>SharedState</code>: Owns any data needed by both the <code>Engine</code> and <code>GUI</code> classes.</li>
</ul>
<p><code>SharedState</code> can loosely be thought of as the Model, and <code>Engine</code> and <code>Editor</code> can loosely be thought of as views into <code>SharedState</code>. <br  />
The reasoning behind this is to force a separation of concerns between different parts of the plugin, by making the <code>Engine</code> and <code>GUI</code> completely independent of one another - any comms between the two should take place through <code>SharedState</code>, via instances of <code><a class="el" href="classmarvin_1_1containers_1_1fifos_1_1SPSC.html" title="A thread-safe, realtime-safe single producer single consumer fifo.">marvin::containers::fifos::SPSC</a></code>.</p>
<p>The framework provides mostly-abstract base classes for the user to implement for each of these areas of the plugin, <code>ISharedState</code>, <code>IEngine</code>, and <code>IEditor</code>.</p>
<p><code>ISharedState</code> requires some extra variables passed from the internal framework, for various useful tasks (running a function on the message thread, and requesting a param flush). These extras are encapsulated in <code>SharedStateContext</code>, which we'll touch on in the next section.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
PluginEntry</h2>
<p>As the user needs to inform the framework of their custom derived <code>SharedState</code>, <code>Engine</code> and <code>Editor</code> classes, we also provide an interface to specify them - <code>IPluginEntry</code>, and a macro (<code><a class="el" href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b" title="Macro to register your IPluginEntry subclass with the framework.">MH_REGISTER_PLUGIN_ENTRY(EntryType)</a></code>) to register the user's custom <code>PluginEntry</code> with the framework.</p>
<p>The framework does <em>not</em> enforce that derived classes must take a pointer to an <code>ISharedState</code> to the <code>Engine</code> and <code>Editor</code> constructors, and that is instead left up to the user to implement - the reasoning being to avoid annoying downcasts every time the custom <code>SharedState</code> class is needed within the other derived types.</p>
<p>However, the function prototypes in <code>IPluginEntry</code> for <code>createEngine</code> and <code>createEditor</code> both take an <code>ISharedState*</code> parameter, which the user can cast to their custom type, and pass to their derived <code>Engine</code> and <code>Editor</code> classes.</p>
<p>As mentioned above, <code>ISharedState</code> needs an instance of <code>SharedStateContext</code> passed to its constructor. This is passed by rvalue ref to <code>IPluginEntry</code>'s <code>createSharedState</code> function, but it is the user's responsibility to forward this arg to their <code>SharedState</code> class' base constructor.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Setting it up</h1>
<p>As mentioned above, in order to create a plugin, the user needs to implement <code>ISharedState</code>, <code>IEngine</code>, <code>IEditor</code>, and <code>IPluginEntry</code>.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
SharedState</h2>
<p>Lets start with the basic boilerplate for our custom <code>SharedState</code> class.</p>
<div class="fragment"><div class="line"><span class="comment">// SharedState.h</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__ISharedState_8h.html">mostly_harmless/core/mostlyharmless_ISharedState.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>SharedState final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a> { <span class="comment">// [1] </span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> SharedState(mostly_harmless::core::SharedStateContext&amp;&amp; context); <span class="comment">// [2]</span></div>
<div class="line">        </div>
<div class="line">    <span class="keyword">private</span>: </div>
<div class="line">        <span class="keywordtype">void</span> loadState(std::string_view toLoad) <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">        <span class="keywordtype">void</span> saveState(std::ostringstream&amp; dest) <span class="keyword">override</span>;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1core_1_1ISharedState_html"><div class="ttname"><a href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a></div><div class="ttdoc">Base class for the plugin&#39;s shared state.</div><div class="ttdef"><b>Definition</b> mostlyharmless_ISharedState.h:26</div></div>
<div class="ttc" id="amostlyharmless__ISharedState_8h_html"><div class="ttname"><a href="mostlyharmless__ISharedState_8h.html">mostlyharmless_ISharedState.h</a></div></div>
</div><!-- fragment --><p>[1] Here we create a class called <code>SharedState</code>, deriving from the framework's <code>ISharedState</code> interface.</p>
<p>[2] As explained earlier, we take an rvalue ref to a <code>SharedStateContext</code>, to be passed to the base class' constructor.</p>
<p>[3] We also override some pure virtual functions from the base, <code>loadState</code> and <code>saveState</code>. These will be called when a host restore's the plugin state, or needs to store the plugin's state respectively.</p>
<p>Next we'll define our functions in a source file.</p>
<div class="fragment"><div class="line"><span class="comment">// SharedState.cpp</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin {</div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { <span class="comment">// [1]</span></div>
<div class="line">        std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">        <span class="comment">// Leave this empty for now</span></div>
<div class="line">        <span class="keywordflow">return</span> params;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SharedState::SharedState(mostly_harmless::core::SharedStateContext&amp;&amp; context) : <a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::ISharedState(std::move(context), createParams()) { <span class="comment">// [2]</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> SharedState::loadState(std::string_view toLoad) { <span class="comment">// [3]</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> SharedState::saveState(std::ostringstream&amp; dest) {</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacemostly__harmless_html"><div class="ttname"><a href="namespacemostly__harmless.html">mostly_harmless</a></div><div class="ttdoc">The top-level namespace, contains all things plugin-related.</div><div class="ttdef"><b>Definition</b> mostlyharmless_BusConfig.h:3</div></div>
</div><!-- fragment --><p>[1] <code>ISharedState</code> also takes a <code>std::vector&lt;Parameter&lt;float&gt;&gt;</code> as its second constructor arg - this is to register any parameters that may exist with the host internally. For this purpose we create a TU scoped free function to create the params, and for the time being, return an empty vector.</p>
<p>[2] Here we pass our <code>context</code> arg, and a newly created vector of params (as explained above) to our base class' constructor.</p>
<p>[3] Finally, we implement our <code>loadState</code> and <code>saveState</code> functions we declared in our header, and leave them empty for now.</p>
<p>We'll return to our <code>SharedState</code> class in a little while once the rest of the boilerplate has been set up. For now, let's move on to the <code>Engine</code> class.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Engine</h2>
<div class="fragment"><div class="line"><span class="comment">// Engine.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__IEngine_8h.html">mostly_harmless/core/mostlyharmless_IEngine.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>IEngine final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1core_1_1IEngine.html">mostly_harmless::core::IEngine</a> { <span class="comment">// [1]</span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> Engine(SharedState* sharedState); <span class="comment">// [2]</span></div>
<div class="line">        <span class="keywordtype">void</span> initialise(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a> context) <span class="keyword">noexcept</span> <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">        <span class="keywordtype">void</span> process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> <span class="keyword">override</span>; <span class="comment">// [4]</span></div>
<div class="line">        <span class="keywordtype">void</span> reset() noexcept override; <span class="comment">// [5]</span></div>
<div class="line">    private: </div>
<div class="line">        SharedState* m_sharedState{ <span class="keyword">nullptr</span> }; <span class="comment">// [2]</span></div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1core_1_1IEngine_html"><div class="ttname"><a href="classmostly__harmless_1_1core_1_1IEngine.html">mostly_harmless::core::IEngine</a></div><div class="ttdoc">Interface for the plugin&#39;s audio processing functionality.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:56</div></div>
<div class="ttc" id="amostlyharmless__IEngine_8h_html"><div class="ttname"><a href="mostlyharmless__IEngine_8h.html">mostlyharmless_IEngine.h</a></div></div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1InitContext_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a></div><div class="ttdoc">Container for context passed to IEngine::initialise.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:17</div></div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1ProcessContext_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a></div><div class="ttdoc">Container for context passed to IEngine::process.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IEngine.h:35</div></div>
</div><!-- fragment --><p>[1] We create an <code>Engine</code> class, deriving from <code>IEngine</code>.</p>
<p>[2] We take a single argument to our constructor, a pointer to our previously set-up <code>SharedState</code> class. We also declare a member variable to store the passed pointer in.</p>
<p>[3] We override <code>initialise</code>, a pure virtual from <code>IEngine</code>, which is called to set up audio processing, before the first call to <code>process</code>. This can be called by any thread by the host, but is guaranteed to not happen concurrently with <code>process</code> or <code>reset</code>.</p>
<p>[4] We override <code>process</code>, a pure virtual from <code>IEngine</code>, which is called on the audio thread by the host to perform some audio processing.</p>
<p>[5] We override <code>reset</code>, a pure virtual from <code>IEngine</code>, which is called to clear any existing internal state by the host, to prepare to be able to play again. This can be called by any thread by the host, but is guaranteed to not happen concurrently with <code>process</code> or <code>initialise</code>.</p>
<p>Next we'll implement all of the above in a source file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Engine.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    Engine::Engine(SharedState* sharedState) : m_sharedState(sharedState) { <span class="comment">// [1]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::initialise(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1InitContext.html">mostly_harmless::core::InitContext</a> context) <span class="keyword">noexcept</span> { <span class="comment">// [2]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> { <span class="comment">// [3]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Engine::reset() noexcept { <span class="comment">// [4]</span></div>
<div class="line">    </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>[1] Here we store the passed <code>SharedState</code> instance in our <code>m_sharedState</code> member, for access later on.</p>
<p>[2] We implement <code>initialise</code>, which takes an <code>InitContext</code>, which is a convenience wrapper for making the args extensible, and contains the host's sample rate (<code>sampleRate</code>), the smallest block size the host can pass (<code>minBlockSize</code>), and the largest block size the host can pass (<code>maxBlockSize</code>).</p>
<p>[3] We implement <code>process</code>, which takes a <code>ProcessContext</code> - again, a convenience wrapper for making the args extensible, which contains a non-owning-view into the buffer passed by the host (<code>buffer</code>), and an optional representing the transport state, if it is available (<code>transport</code>).</p>
<p>[4] We implement <code>reset</code>, as detailed above.</p>
<p>Next, let's implement our <code>Editor</code> class.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Editor</h2>
<p>The editor class is a bit more complex than all of the above. Mostly harmless doesn't come with a gui framework bolted on, ala JUCE, and instead expects the user to implement whatever gui framework they like, via the hooks in the <code>IEditor</code> class.</p>
<p>That being said, the framework provides abstractions over <code>IEditor</code> for a webview gui, with varying degrees of opinionated-ness. More frameworks are planned here, such as Slint, but for now, Webviews are the only fully featured option out of the box.</p>
<p>A full javascript / html / css / trendy web framework tutorial here is obviously out of scope, so we'll instead assume that some gui project exists within our current project, and we'll focus on the C++ side setup to call into this imaginary gui project. Down the line, a tutorial is planned for the full setup, but for now, the <code>Gain</code> example will have to suffice, which uses React and Vite.</p>
<p>Disclaimers aside, let's talk specifics on the levels of abstraction mostly harmless provides:</p>
<ul>
<li><code>IEditor</code> is the aforementioned interface, with no additional functionality.</li>
<li><code>WebviewBase</code> handles cross platform window management, and creates a webview for the user to use as they see fit. It does <em>not</em> handle bidirectional parameter communications for the user, and exists to serve as an unopinionated abstraction layer over <code>IEditor</code>.</li>
<li><code>WebviewEditor</code> derives from <code>WebviewBase</code>, and takes things a step further. It establishes bindings to javascript events for bidirection parameter comms for the user, and handles the majority of the plumbing between C++ and Javascript.</li>
</ul>
<p>In this tutorial, we'll use <code>WebviewEditor</code> for simplicity.</p>
<div class="fragment"><div class="line"><span class="comment">// Editor.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mostlyharmless__WebviewEditor_8h.html">mostly_harmless/gui/mostlyharmless_WebviewEditor.h</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">class </span>Editor final : <span class="keyword">public</span> <a class="code hl_class" href="classmostly__harmless_1_1gui_1_1WebviewEditor.html">mostly_harmless::gui::WebviewEditor</a> {  <span class="comment">// [1]</span></div>
<div class="line">    <span class="keyword">public</span>: </div>
<div class="line">        <span class="keyword">explicit</span> Editor(SharedState* sharedState); <span class="comment">// [2]</span></div>
<div class="line">        <span class="keywordtype">void</span> initialise() <span class="keyword">override</span>; <span class="comment">// [3]</span></div>
<div class="line">    <span class="keyword">private</span>: </div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> m_windowWidth{ 500 }; <span class="comment">// [4]</span></div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> m_windowHeight{ 500 };    </div>
<div class="line">        <span class="keyword">const</span> mostly_harmless::gui::Colour m_backgroundColour{ 0xFF000000 };</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1gui_1_1WebviewEditor_html"><div class="ttname"><a href="classmostly__harmless_1_1gui_1_1WebviewEditor.html">mostly_harmless::gui::WebviewEditor</a></div><div class="ttdoc">An opinionated subclass of WebviewBase, providing default impls for bidirectional comms.</div><div class="ttdef"><b>Definition</b> mostlyharmless_WebviewEditor.h:92</div></div>
<div class="ttc" id="amostlyharmless__WebviewEditor_8h_html"><div class="ttname"><a href="mostlyharmless__WebviewEditor_8h.html">mostlyharmless_WebviewEditor.h</a></div></div>
</div><!-- fragment --><p>[1] We declare an <code>Editor</code> class, deriving from <code>WebviewEditor</code>, as discussed above.</p>
<p>[2] Our constructor again takes a pointer to our <code>SharedState</code> class. Because we're deriving from <code>WebviewEditor</code>, which actually <em>does</em> require an <code>ISharedState*</code> passed to its constructor, we in this case don't keep this pointer as a member.</p>
<p>[3] We implement the <code>initialise</code> function, which is <em>not</em> pure virtual, but is where we need to inject any more functionality for after the webview has been created.</p>
<p>[4] We define some compile time constants for our plugin window's width, height and background colour as members.</p>
<p>Next lets implement all of this in a source file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Editor.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    Editor::Editor(SharedState* sharedState) : </div>
<div class="line">     <a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::gui::WebviewEditor(sharedState, m_width, m_height, m_backgroundColour) { <span class="comment">// [1]</span></div>
<div class="line">        setOptions({.enableDebug = <span class="keyword">true</span> }); <span class="comment">// [2]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> Editor::initialise() { </div>
<div class="line">        <a class="code hl_function" href="classmostly__harmless_1_1gui_1_1WebviewEditor.html#a1f971ab269931475d34d5dca242f563d">mostly_harmless::gui::WebviewEditor::initialise</a>(); <span class="comment">// [3]</span></div>
<div class="line">        m_internalWebview-&gt;navigate(<span class="stringliteral">&quot;http://localhost:5173&quot;</span>); <span class="comment">// [4]</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassmostly__harmless_1_1gui_1_1WebviewEditor_html_a1f971ab269931475d34d5dca242f563d"><div class="ttname"><a href="classmostly__harmless_1_1gui_1_1WebviewEditor.html#a1f971ab269931475d34d5dca242f563d">mostly_harmless::gui::WebviewEditor::initialise</a></div><div class="ttdeci">void initialise() override</div></div>
</div><!-- fragment --><p>[1] Here we call our <code>WebviewEditor</code> class' constructor, which takes our pointer to an <code>ISharedState</code>, our desired window width and height, and our desired window's background colour.</p>
<p>[2] For now, we just enable inspect-element functionality on the webview - more options are available here, which we'll discuss later.</p>
<p>[3] <code>WebviewEditor</code>'s <code>initialise</code> function is <em>not</em> pure virtual, so we still need to call it before doing our own custom behaviour in <code>initialise</code>.</p>
<p>[4] For now, we load our gui from localhost - in a later tutorial, we'll talk through instead serving the webview from ram.</p>
<p>We're nearly done with our boilerplate, the last thing we need to do is register our derived classes with the framework.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
PluginEntry</h2>
<p>As discussed earlier, <code>IPluginEntry</code> is our interface for doing so.</p>
<div class="fragment"><div class="line"><span class="comment">// PluginEntry.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;SharedState.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Engine.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Editor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mostly_harmless/core/mostlyharmess_IPluginEntry.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    <span class="keyword">struct </span>PluginEntry final : <span class="keyword">public</span> <a class="code hl_struct" href="structmostly__harmless_1_1core_1_1IPluginEntry.html">mostly_harmless::core::IPluginEntry</a> { </div>
<div class="line">    <span class="keyword">public</span>:    </div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;mostly_harmless::core::ISharedState&gt; createState(mostly_harmless::core::SharedStateContext&amp;&amp; context) <span class="keyword">override</span>; </div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;mostly_harmless::Core::IEngine&gt; createEngine(<a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a>* sharedState) <span class="keyword">override</span>;</div>
<div class="line">        [[nodiscard]] <span class="keywordtype">bool</span> hasGui() const noexcept override;</div>
<div class="line">        [[nodiscard]] std::unique_ptr&lt;<a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::IEditor&gt; createEditor(<a class="code hl_namespace" href="namespacemostly__harmless.html">mostly_harmless</a>::core::ISharedState* sharedState) override; </div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="astructmostly__harmless_1_1core_1_1IPluginEntry_html"><div class="ttname"><a href="structmostly__harmless_1_1core_1_1IPluginEntry.html">mostly_harmless::core::IPluginEntry</a></div><div class="ttdoc">Interface for registering the user&#39;s subclasses with the framework.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IPluginEntry.h:20</div></div>
</div><!-- fragment --><p>Our header is relatively self explanatory, so let's implement those functions in our source file.</p>
<div class="fragment"><div class="line"><span class="comment">// PluginEntry.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;PluginEntry.h&quot;</span></div>
<div class="line"><span class="keyword">namespace </span>myplugin { </div>
<div class="line">    SharedState* asUserState(<a class="code hl_class" href="classmostly__harmless_1_1core_1_1ISharedState.html">mostly_harmless::core::ISharedState</a>* sharedState) { <span class="comment">// [1]</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>SharedState*<span class="keyword">&gt;</span>(sharedState);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::core::ISharedState&gt; PluginEntry::createState(mostly_harmless::core::SharedStateContext&amp;&amp; context) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;SharedState&gt;(std::move(context)); <span class="comment">// [2]</span></div>
<div class="line">    } </div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::Core::IEngine&gt; PluginEntry::createEngine(mostly_harmless::core::ISharedState* sharedState) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;Engine&gt;(asUserState(sharedState)); <span class="comment">// [3]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> PluginEntry::hasGui() const noexcept { <span class="comment">// [4]</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::unique_ptr&lt;mostly_harmless::core::IEditor&gt; PluginEntry::createEditor(mostly_harmless::core::ISharedState* sharedState) { </div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;Editor&gt;(asUserState(sharedState)); <span class="comment">// [5]</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"><a class="code hl_define" href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b">MH_REGISTER_PLUGIN_ENTRY</a>(myplugin::PluginEntry); <span class="comment">// [6]</span></div>
<div class="ttc" id="amostlyharmless__IPluginEntry_8h_html_ab7eec3b8c12426bc21578d0f27768f0b"><div class="ttname"><a href="mostlyharmless__IPluginEntry_8h.html#ab7eec3b8c12426bc21578d0f27768f0b">MH_REGISTER_PLUGIN_ENTRY</a></div><div class="ttdeci">#define MH_REGISTER_PLUGIN_ENTRY(PluginEntryType)</div><div class="ttdoc">Macro to register your IPluginEntry subclass with the framework.</div><div class="ttdef"><b>Definition</b> mostlyharmless_IPluginEntry.h:61</div></div>
</div><!-- fragment --><p>[1] We declare a TU scoped helper function to avoid verbose static casts, for downcasting our <code>ISharedEditor</code> points to our user <code>SharedState</code> class.</p>
<p>[2] We create our user <code>SharedState</code> class, forwarding it the <code>context</code> arg by move.</p>
<p>[3] We create our <code>Engine</code> class, passing it a downcast-to-user-state of <code>sharedState</code>.</p>
<p>[4] We return true from <code>hasGui()</code>. In the case of a headless plugin, we can return false here, and return a nullptr from <code>createEditor</code>.</p>
<p>[5] We create our <code>Editor</code> class, passing it a downcast-to-user-state of <code>sharedState</code>.</p>
<p>[6] Finally, we call a macro to register this <code>PluginEntry</code> class with the framework. Internally this defines a free function, <code>createPluginEntry</code>, which returns our user <code>PluginEntry</code> type. The internal framework class then uses its hooks to create <code>SharedState</code>, <code>Engine</code> and <code>Editor</code> classes, and forwards relevant function calls to the appropriate places within there classes.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Getting it building</h1>
<p>Mostly harmless uses cmake, and provides some CMake helpers to make setting up your plugin a little more painless.</p>
<p>Familiarity with CMake is assumed here, and some typical options have been ommitted for the sake of brevity (macOS arch to build, windows runtime linking type, codesigning, etc).</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.24)</div>
<div class="line">set(CMAKE_CXX_STANDARD 20)</div>
<div class="line">project(MyPlugin VERSION 0.0.1)</div>
<div class="line">include(FetchContent)</div>
<div class="line">FetchContent_Declare(mostly_harmless</div>
<div class="line">        GIT_REPOSITORY https://github.com/SLM-Audio/mostly-harmless.git</div>
<div class="line">        GIT_TAG main</div>
<div class="line">        GIT_SHALLOW ON</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(mostly_harmless) # [1]</div>
<div class="line"> </div>
<div class="line">mostly_harmless_add_plugin(MyPlugin # [2]</div>
<div class="line">        ID &quot;yourcompany.yourplugin&quot;</div>
<div class="line">        VENDOR &quot;Your Company&quot;</div>
<div class="line">        FORMATS CLAP AU VST3 Standalone # [3]</div>
<div class="line">        AU_BUNDLE_ID &quot;com.yourcompany.yourplugin&quot;</div>
<div class="line">        AU_BUNDLE_VERSION &quot;1&quot;</div>
<div class="line">        MANUFACTURER_CODE &quot;Yrco&quot;</div>
<div class="line">        SUBTYPE_CODE &quot;Ypi1&quot;</div>
<div class="line">        AU_TYPE &quot;aufx&quot;</div>
<div class="line">        FEATURES &quot;audio-effect&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_sources(MyPlugin PRIVATE # [4]</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/PluginEntry.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/SharedState.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/Engine.cpp</div>
<div class="line">        ${CMAKE_CURRENT_SOURCE_DIR}/source/Editor.cpp</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_include_directories(MyPlugin PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/source) # [5]</div>
</div><!-- fragment --><p>[1] We pull in mostly harmless via fetch content - in real life, you probably want to pin this to a specific SHA or tag.</p>
<p>[2] Mostly harmless provides <code>mostly_harmless_add_plugin</code>, which will set up the specified plugin targets for you, and automatically handle the internal linking, etc.</p>
<p>[3] This is where we specify what formats we want to build. Note that AU requires some extra arguments that the other targets don't - see <a class="el" href="README_8md.html">README.md</a> for more info on this.</p>
<p>[4] We specify what source files the plugin should compile.</p>
<p>[5] We set the <code>source</code> directory as an include directory for convenience.</p>
<p>At this point, you should be at a stage where your plugin is compiling!</p>
<h1><a class="anchor" id="autotoc_md26"></a>
A Gain Plugin</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
Modifying the input signal's level</h2>
<p>Let's start simple - multiply the audio input by 0.5. Jumping back to our <code>Engine</code> class, our <code>process</code> function is the place to do so.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> { </div>
<div class="line">  <span class="keyword">auto</span> buffer = context.buffer;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Firstly, we retrieve the buffer (a <code><a class="el" href="structmarvin_1_1containers_1_1BufferView.html" title="Trivially copyable view into a preallocated SampleType**.">marvin::containers::BufferView</a>&lt;float&gt;</code>) from the <code>context</code>. You can take a look at the docs for <code>BufferView</code>, but it can pretty much be thought of a <code>std::span</code> but for an audio buffer - that is, a non owning view into the passed in audio buffer. Internally in the framework, for sample accurate automation, this buffer view will be from index_of_last_event to index_of_current_event - essentially it's interrupted whenever there's a new param/midi event. See <code><a class="el" href="namespacemostly__harmless.html#a8d2d74acdc833b5d2eef76b423e9cf89" title="Splits an input buffer into chunks and dispatches them, allowing for block based processing.">mostly_harmless::runBlockDispatch</a></code> for a more in-depth explanation of this.</p>
<p><code>BufferView</code> provides functions to grab read / write pointers (RAW pointers) to the underlying data. It's worth noting that these actually point to the same memory, just with different access modifiers, which is a holdover from my JUCE muscle memory.</p>
<p>To start with then, lets grab our read and write pointers..</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers(); <span class="comment">// const T* const *</span></div>
<div class="line"><span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers(); <span class="comment">// T* const *</span></div>
</div><!-- fragment --><p>Now we're set up to apply our gain:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers(); <span class="comment">// const T* const *</span></div>
<div class="line"><span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers(); <span class="comment">// T* const *</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> sample = 0; sample &lt; buffer.getNumSamples(); ++sample) { <span class="comment">// iterate over the samples</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> channel = 0_sz; channel &lt; buffer.getNumChannels(); ++channel) { <span class="comment">// iterate over the channels</span></div>
<div class="line">        write[channel][sample] = read[channel][sample] * 0.5f; <span class="comment">// multiply our input signal by 0.5, and write to the output signal.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running this, you should hear it attenuating the input signal. Great! Now lets make the gain modifyable.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Parameters</h2>
<p>Earlier I mentioned that <code>ISharedState</code> takes a vector of parameters to its constructor, which registers them internally, and we defined a TU-scoped free function to create our params. Let's revisit that:</p>
<div class="fragment"><div class="line">std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { </div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now - <code><a class="el" href="structmostly__harmless_1_1Parameter.html" title="Container class for a single parameter.">mostly_harmless::Parameter</a>&lt;float&gt;</code> - whats the deal with that? At this point it's helpful to get slightly sidetracked, and take a look at the documentation. It's worth noting that there are two overloads of Parameter's constructor - one that takes a ParameterID, and another that takes a raw std::uint32_t. We'll focus on the former here, but you can learn the difference between the two by checking the documentation. The main things we need to worry about here are <code>pid</code>, <code>name</code>, <code>category</code>, <code>range</code>, <code>defaultValue</code> and <code>flags</code>.</p>
<ul>
<li><code>parameterId</code> is the internally used param id.</li>
<li><code>name</code> is the parameter's name, which will be displayed in the host.</li>
<li><code>category</code> is a clap-specific thing, in which you can separate certain parameters by category - this specifies the category.</li>
<li><code>range</code> is the range of the parameter.</li>
<li><code>defaultValue</code> is, intuitively, the default value of the parameter.</li>
<li><code>flags</code> is a set of clap defined flags, to control the parameter's properties.</li>
</ul>
<p><code>parameterId</code> needs a little elaboration here. In CLAP, the id for a given parameter must be fixed to avoid breaking automation, old presets, old states, and generally maintain backwards compatability. So rather than getting you (the user) to pick an arbitrary unique uint32_t for each parameter, we provide ParameterID. This class takes a non-owning view to a string, and generates that string's hash at construction - the hash is then used as the internal param id. We could have generated this from <code>name</code>, but separating the two allows you to rename the host/user facing param name at any point, without breaking existing projects, etc. This of course means that the string passed to ParameterID must not change once your plugin is in the wild - this is reiterated a few times in the documentation, but just to really hammer it home...</p>
<p>With that out of the way, armed with our newfound knowledge, lets populate our <code>createParams</code> function.</p>
<div class="fragment"><div class="line">std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; createParams() { </div>
<div class="line">    std::vector&lt;mostly_harmless::Parameter&lt;float&gt;&gt; params;</div>
<div class="line">    params.emplace_back(<a class="code hl_struct" href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter&lt;float&gt;</a>{ </div>
<div class="line">        <a class="code hl_struct" href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a>{<span class="stringliteral">&quot;gain&quot;</span>}, <span class="comment">// pid</span></div>
<div class="line">        <span class="stringliteral">&quot;Gain&quot;</span>, <span class="comment">// name</span></div>
<div class="line">        <span class="stringliteral">&quot;gain/&quot;</span>, <span class="comment">// category</span></div>
<div class="line">        {.min = 0.0f, .max = 1.0f}, <span class="comment">// range,</span></div>
<div class="line">        1.0f, <span class="comment">// defaultValue</span></div>
<div class="line">        CLAP_PARAM_IS_AUTOMATABLE <span class="comment">// flags</span></div>
<div class="line">    });</div>
<div class="line">    <span class="keywordflow">return</span> params;</div>
<div class="line">}</div>
<div class="ttc" id="astructmostly__harmless_1_1ParameterID_html"><div class="ttname"><a href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a></div><div class="ttdoc">Convenience class for generating a parameter id.</div><div class="ttdef"><b>Definition</b> mostlyharmless_Parameters.h:15</div></div>
<div class="ttc" id="astructmostly__harmless_1_1Parameter_html"><div class="ttname"><a href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter</a></div><div class="ttdoc">Container class for a single parameter.</div><div class="ttdef"><b>Definition</b> mostlyharmless_Parameters.h:41</div></div>
</div><!-- fragment --><p>With this in place, we've created a gain parameter. <code>ISharedState</code> provides a <code>getParameterById</code> function which we can use to retrieve a parameter by either a ParameterID, or a <code>std::uint32_t</code> (the latter being useful if you want to precalculate your hashes, and keep them around in shared state, etc.</p>
<p>However, both of these overloads perform a lookup in a <code>std::unordered_map</code>. We can live with this, but can also do better. Still within our <code>ISharedState</code> header/source, lets declare a new type, <code>ParameterView</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ParameterView final { </div>
<div class="line">    <a class="code hl_struct" href="structmostly__harmless_1_1Parameter.html">mostly_harmless::Parameter&lt;float&gt;</a>* gainParam{ <span class="keyword">nullptr</span> };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SharedState ....</div>
</div><!-- fragment --><p>And now let's create an instance of <code>ParameterView</code> as a member of <code>SharedContext</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>: </div>
<div class="line">    <span class="keywordtype">void</span> loadState(...</div>
<div class="line">    <span class="keywordtype">void</span> saveState(...</div>
<div class="line">    </div>
<div class="line">    ParameterView m_paramView;</div>
</div><!-- fragment --><p>In <code>SharedState</code>'s constructor, we need to initialise <code>m_paramView</code>'s <code>gainParam</code> pointer to a valid parameter:</p>
<div class="fragment"><div class="line">SharedState::SharedState(....) : .... { </div>
<div class="line">    <span class="keywordflow">if</span>(<span class="keyword">auto</span> param = getParameterById(<a class="code hl_struct" href="structmostly__harmless_1_1ParameterID.html">mostly_harmless::ParameterID</a>{<span class="stringliteral">&quot;gain&quot;</span>}) { </div>
<div class="line">        m_paramView.gainParam = param; </div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> { </div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We've now set up a trivially copyable struct containing raw pointers to our params, and the only lookups happen at construction. To use this in our <code>Engine</code> and <code>Editor</code> classes, we need to create a getter:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SharedState final : .... { </div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line">    ...</div>
<div class="line">    [[nodiscard]] ParameterView getParamView() const noexcept;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">ParameterView SharedState::getParamView() const noexcept { </div>
<div class="line">    <span class="keywordflow">return</span> m_paramView;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can finally grab the parameter in our Engine now:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Engine::process(<a class="code hl_struct" href="structmostly__harmless_1_1core_1_1ProcessContext.html">mostly_harmless::core::ProcessContext</a> context) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keyword">auto</span> buffer = context.buffer;</div>
<div class="line">    <span class="keyword">auto</span> paramView = m_sharedState-&gt;getParamView();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> gain = paramView.gainParam-&gt;value;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* <span class="keyword">const</span>* read = buffer.getArrayOfReadPointers();                   </div>
<div class="line">    <span class="keyword">auto</span>* <span class="keyword">const</span>* write = buffer.getArrayOfWritePointers();                      </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> sample = 0; sample &lt; buffer.getNumSamples(); ++sample) {       </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> channel = 0_sz; channel &lt; buffer.getNumChannels(); ++channel) {</div>
<div class="line">            write[channel][sample] = read[channel][sample] * gain;             </div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>// TODO: MORE </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
