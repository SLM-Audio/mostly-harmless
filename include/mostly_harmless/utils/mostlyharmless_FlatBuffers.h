//
// Created by Syl Morrison on 06/09/2025.
//

#ifndef MOSTLYHARMLESS_FLATBUFFERS_H
#define MOSTLYHARMLESS_FLATBUFFERS_H
#include <flatbuffers/flatbuffers.h>

namespace mostly_harmless::utils::flat_buffers {
    /**
     * \brief Represents a flatbuffer autogenerated SomethingT type
     **/
    template<typename T>
    concept FlatBufferType = std::is_base_of_v<flatbuffers::NativeTable, T>;


    /**
     * \brief Handles serialising or deserialising flat buffer data.
     * Serialised data is tied to the lifecycle of a flatbuffer::FlatBufferBuilder - rather than requiring the user learn the ins and outs of the flatbuffer api,
     * this class owns a FlatBufferBuilder.
     * Subsequent calls to `serialise` will clear the builder's buffer, so if serialising multiple flat buffers in a loop, be sure to copy the serialised data into a
     * concrete vector etc!
     */
    class Serialiser final {
    public:
        /**
         * Constructor
         * @param initialAllocSize The initial alloc size, to pass to the flatbuffer builder
         */
        explicit Serialiser(size_t initialAllocSize);

        /**
         * Given an autogenerated flatbuffer SomethingT type, serialises the data.
         * As mentioned above, calling serialise will clear the internal builder's buffer, and the return value from this function's lifecycle is tied to that builder,
         * so ensure you've done what you need to with the data before calling this function again!
         * @tparam T An autogenerated flatbuffer YourTypeT type
         * @param toSerialise The data you want to serialise
         * @return A view into the resulting serialised buffer.
         */
        template<FlatBufferType T>
        [[nodiscard]] std::span<std::uint8_t> serialise(T &toSerialise) {
            using Underlying = typename T::TableType;
            m_builder.Clear();
            auto packed = Underlying::Pack(m_builder, &toSerialise);
            m_builder.Finish(packed);
            return {m_builder.GetBufferPointer(), m_builder.GetSize()};
        }


        /**
         * Deserialises the given buffer into a flatbuffer autogenerated YourTypeT.
         * In this case, the internal builder isn't used at all (hence being static), and the return value's lifecycle is tied to that of your input data.
         * @tparam T A flatbuffer autogenerated YourTypeT
         * @param toDeserialise A view into the data to deserialise
         * @return A pointer to the resulting YourTypeT
         */
        template<FlatBufferType T>
        [[nodiscard]] static T *deserialise(std::span<std::uint8_t> toDeserialise) {
            using Underlying = typename T::TableType;
            auto *root = flatbuffers::GetRoot<Underlying>(toDeserialise.data());
            auto *res = root->UnPack();
            return res;
        }

    private:
        flatbuffers::FlatBufferBuilder m_builder;
    };
}
#endif //MOSTLYHARMLESS_FLATBUFFERS_H
